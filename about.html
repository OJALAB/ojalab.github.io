<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>About – OJALAB</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-3fced2653c1411365395c6308d7f7025.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">OJALAB</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./about.html" aria-current="page"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./news.html"> 
<span class="menu-text">News</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./opportunities.html"> 
<span class="menu-text">Opportunities</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./people.html"> 
<span class="menu-text">People</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#research-plan" id="toc-research-plan" class="nav-link" data-scroll-target="#research-plan">Research Plan</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<div style="text-align: justify;">
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true">English</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false">Polish</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p>Measuring the size and characteristics of the demand for labour is not an easy task. On the one hand, increasing non-response and under-reporting in business sample surveys introduce bias in job vacancy estimates and the limited scope of surveys does not allow to provide estimates of skills and competencies demand or to cover all types of contracts (e.g.&nbsp;contract agreement, B2B). On the other hand, administrative data and the Internet cover thousands of job ads full of valuable information but direct usage of these sources for statistics is limited by the coverage and selection error. While there are plenty of applications of job ads for describing demand, mismatch or matching little is done in order to correct for measurement error or non-representativeness. Thus, results based on these studies may provide wrong recommendations for the policymakers.</p>
<p>Therefore, this project aims to tackle these problems using modern statistical methods and propagate uncertainty in macroeconomic analysis and policy guidance. The main objective of the project is to develop new methods to measure the size and characteristics of the job vacancies (including non-standard and flexible work contracts) based on the survey, online and administrative data, and apply it to analyse the short-run and long-run developments of the vacancy market in Poland and the matching technology. To fulfil the main objective we identify five specific objectives.</p>
<p>Firstly, we will propose a new approach to estimate the number of vacancies, which is based solely on online and administrative data using capture-recapture and latent class analysis methods. To fill this task we will use data from public employment offices and several online services. These data require cleaning and deduplication procedures that we plan to develop during the project. Classification algorithms will be developed to identify employers and job characteristics (e.g.&nbsp;occupation, skills, type of contract).</p>
<p>Secondly, we will correct for non-representativeness of big data sources by usage of the Demand for Labour survey (Statistics Poland). To tackle this problem we will use data integration methods and extend them for measurement error as all variables from job ads will be obtained from classification algorithms. In additiion, results from task will be used to correct survey weights. In this task, we will closely work with an expert from the North Carolina State University, USA.</p>
<p>Thirdly, we will use results from task 1 &amp; 2 to estimate the size and structure of demand for skills. This will supply unique variables that cannot be obtained in surveys, such as skills, contract types or contract mode (remote, hybrid, mobile, traditional). Thanks to this we will analyse the skill evolution both between occupations and within them. This will show the evolution of skill reqirements and will help anticipate skill needs.</p>
<p>Fourthly, as we have access to data before the COVID-19 pandemic and migration inflow of Ukrainians we will verify hypotheses about the structural change in the labour market. COVID-19 recession sped up the process of labour market transformation – online work and more flexible work contracts, such as B2B. Such contracts are not included in employment estimates in the official statistics, while they have a profound effect on the labour market. The inflow of migrants may be an opportunity for firms, but to unknown extent. We will test and model the structural change.</p>
<p>Finally, thanks to unique data on job offers and job seekers’ behaviour we will analyse the search and matching process in more detail than it has been done before. In this task, we will use and merge rich unit-level data on the unemployed and job offers from public employment offices, thanks to the information on the matches between them, that we already possess. It will enable to test influence of requirements from individual job offers and histories of unemployed persons on job search.</p>
<p>We plan to work according to the open science principles, i.e.&nbsp;we plan to use and develop open-source software, make the algorithms and data available to the public and present the work in open access journals.</p>
<p>We believe that the project will have an impact not only on official statistics through developing new methods for non-probability samples and integration of statistical and non-statistical sources but also on labour market economics and policy, providing new, in-depth, and reliable information about the vacancy market.</p>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p>Pomiar wielkości i charakterystyk popytu na pracę nie jest łatwym zadaniem. Z jednej strony rosnący brak odpowiedzi i niedoszacowanie w badaniach przedsiębiorstw wprowadzają błędy w szacunkach wolnych miejsc pracy, a ograniczony zakres badań nie pozwala na oszacowanie popytu na umiejętności ani na uwzględnienie wszystkich typów umów o pracę (np. umowa o dzieło, Business-to-Business). Z drugiej strony dane administracyjne i internetowe obejmują tysiące ogłoszeń o pracę, zawierających cenne informacje, ale bezpośrednie wykorzystanie tych źródeł w statystyce jest ograniczone przez błędy pokrycia i selekcji. Chociaż istnieje wiele zastosowań ogłoszeń o pracy do opisu popytu na umiejętności, niewiele robi się w celu skorygowania błędów pomiaru lub niereprezentatywności. W rezultacie wyniki oparte na tych badaniach mogą dostarczać błędnych rekomendacji dla decydentów politycznych.</p>
<p>Projekt ma na celu rozwiązanie tych problemów za pomocą nowoczesnych metod statystycznych i propagowanie włączenia ocen niepewności do analiz makroekonomicznych i wskazań polityki gospodarczej. Głównym celem projektu jest opracowanie nowych metod pomiaru wielkości i charakterystyk wolnych miejsc pracy (w tym niestandardowych i elastycznych umów o pracę) na podstawie danych z badań reprezentacyjnych, danych internetowych i rejestrów administracyjnych oraz zastosowanie ich do analiz krótko- i długookresowych zmian na rynku wolnych miejsc pracy w Polsce, a także technologii dopasowań pomiędzy uczestnikami rynku pracy. Aby zrealizować cel główny, formułujemy pięć celów pomocniczych.</p>
<p>Po pierwsze, zaproponujemy nowe podejście do szacowania liczby wolnych miejsc pracy, oparte wyłącznie na danych internetowych i administracyjnych, wykorzystując metody capture-recapture i analizy klas ukrytych. W tym celu wykorzystamy dane z urzędów pracy i serwisów internetowych. Dane te wymagają czyszczenia i deduplikacji, których metody planujemy dopracować w ramach projektu. Opracujemy algorytmy klasyfikacji w celu identyfikacji pracodawców i różnych charakterystyk pracy (np. zawodu, umiejętności, typu umowy o pracę).</p>
<p>Po drugie, skorygujemy niereprezentatywność dużych zbiorów danych za pomocą Badania Popytu na Pracę (GUS). Aby rozwiązać ten problem, wykorzystamy metody integracji danych i rozszerzymy je o uwzględnienie błędów pomiaru, ponieważ wszystkie zmienne utworzone na podstawie ogłoszeń o pracy będą utworzone na podstawie zastosowania algorytmów klasyfikacji. Ponadto wyniki z tego zadania zostaną wykorzystane do korekty wag badań reprezentacyjnych.</p>
<p>Po trzecie, wykorzystamy wyniki z zadań 1 i 2 do oszacowania wielkości i struktury popytu na umiejętności. Dostarczy to unikalnych zmiennych, których nie można uzyskać w badaniach reprezentacyjnych. Są to: umiejętności, rodzaje umów o pracę, tryb pracy (zdalna, hybrydowa, mobilna, tradycyjna) i inne. Dzięki temu przeanalizujemy ewolucję umiejętności zarówno pomiędzy zawodami, jak i w ich obrębie. Pozwoli to na analizę przeobrażeń w wymaganiach na umiejętności i pomoże przewidzieć przyszłe potrzeby na poszczególne kompetencje.</p>
<p>Po czwarte, mając dostęp do danych sprzed pandemii COVID-19 i napływu migrantów z Ukrainy, zweryfikujemy hipotezy dotyczące zmian strukturalnych na rynku pracy. Recesja COVID-19 przyspieszyła proces transformacji rynku pracy, w tym korzystanie z pracy zdalnej i elastycznych umów o pracę, takich jak umowy typu Business-to-Business. Takie umowy nie są uwzględniane w szacunkach wakatów dokonywanych w ramach statystyki oficjalnej, ale mogą mieć znaczący wpływ na rynek pracy. Z kolei napływ uchodźców z Ukrainy może być dla polskich przedsiębiorstw szansą, ale w trudnym do określenia stopniu. Nie wiadomo bowiem czy imigranci konkurują o miejsca pracy z rodzimymi pracownikami, czy uzupełniają występujące na rynku luki. Będziemy testować i modelować zmiany strukturalne.</p>
<p>W ostatnim zadaniu, dzięki unikalnym danym na temat ofert pracy i zachowań poszukujących pracy przeanalizujemy proces poszukiwań na rynku pracy bardziej szczegółowo niż było to możliwe wcześniej. W tym zadaniu wykorzystamy i połączymy bogate mikrodane na temat bezrobotnych i ofert pracy z urzędów pracy, dzięki informacjom o dopasowaniach pomiędzy nimi. Pozwoli to przetestować wpływ wymagań z poszczególnych ofert pracy i historii bezrobotnych na proces efektywność dopasowań pomiędzy nimi.</p>
<p>W projekcie planujemy pracować zgodnie z zasadami otwartej nauki, tj. korzystać z oprogramowania na otwartych licencjach, publicznie udostępniać algorytmy i dane oraz prezentować prace w czasopismach o otwartym dostępie.</p>
<p>Wierzymy, że projekt będzie miał wpływ nie tylko na statystykę oficjalną poprzez opracowanie nowych metod dla prób nielosowych i integrację źródeł statystycznych i niestatystycznych, ale także na ekonomię rynku pracy i politykę gospodarczą, dostarczając nowych, szczegółowych i wiarygodnych informacji na temat rynku wolnych miejsc pracy.</p>
</div>
</div>
</div>
</div>
</section>
<section id="research-plan" class="level2">
<h2 class="anchored" data-anchor-id="research-plan">Research Plan</h2>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-2-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-1" role="tab" aria-controls="tabset-2-1" aria-selected="true">English</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-2-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-2" role="tab" aria-controls="tabset-2-2" aria-selected="false">Polish</a></li></ul>
<div class="tab-content">
<div id="tabset-2-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-2-1-tab">
<ol type="1">
<li>Web-scraping and statistical analysis of data used in the project</li>
<li>Developing new methods to assess quality of online data</li>
<li>Developing new methods for estimation of the number of job vacancies</li>
<li>Developing new data integration methods for non-probability samples with mis-classification</li>
<li>Estimation of the quality of non-random sources (admin and online data)</li>
<li>Estimation of the number of job vacancies (total and sub-populations)</li>
<li>Estimation of demand for skills and competencies based on admin and online data</li>
<li>Descriptive and economic analysis based on estimated data</li>
<li>Analysis and modelling skills over time</li>
<li>Analysis of structural developments of the labour market in relation to the COVID-19 pandemic and war in Ukraine</li>
<li>Estimation of skill matching using admin and online unit-level data under mis-classification</li>
</ol>
</div>
<div id="tabset-2-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-2-2-tab">
<ol type="1">
<li>Web-scraping i analiza statystyczna danych wykorzystywanych w projekcie</li>
<li>Opracowanie nowych metod oceny jakości danych online</li>
<li>Opracowanie nowych metod szacowania liczby wolnych miejsc pracy</li>
<li>Opracowanie nowych metod estymacji z wykorzystaniem prób nieprobabilistycznych uwzględniających błąd klasyfikacji</li>
<li>Estymacja wskaźników jakości dla prób nieprobabilistycznych</li>
<li>Oszacowanie liczby wolnych miejsc pracy (ogółem i w wybranych przekrojach)</li>
<li>Oszacowanie popytu na umiejętności i kompetencje na podstawie danych administracyjnych i online</li>
<li>Analiza opisowa i ekonomiczna uzyskanych danych</li>
<li>Analiza i modelowanie umiejętności w czasie</li>
<li>Analiza zmian strukturalnych na rynku pracy w relacji do pandemii COVID-19 i wojny w Ukrainie</li>
<li>Oszacowanie mechanizmu dopasowań pod względem umiejętności na rynku pracy przy wykorzystaniu danych jednostkowych adresując problemy błędów klasyfikacji</li>
</ol>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/ojalab\.ue\.poznan\.pl");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>